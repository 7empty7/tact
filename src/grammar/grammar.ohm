Tact {

    // Starting point of the program
    Program = ProgramItem*
    ProgramItem = Struct
                | Contract
                | Primitive
                | StaticFunction
                | NativeFunction

    // Built-in declarations
    Primitive = primitive Type ";"

    // Static function
    StaticFunction = Function
    NativeFunction = nameAttribute "(" funcId ")" FunctionAttribute* native id "(" ListOf<FunctionArg,","> ")" ";" --withVoid
                   | nameAttribute "(" funcId ")" FunctionAttribute* native id "(" ListOf<FunctionArg,","> ")" ":" Type ";" --withType
    
    // Field declarations
    Type = typeLiteral "?" --optional
         | typeLiteral --required
         | "map" "[" typeLiteral "]" typeLiteral --map
    Field = id ":" Type ";" --default
          | id ":" Type "=" Expression ";" --defaultWithInit
          | id ":" Type as id ";" --withSerialization
          | id ":" Type as id "=" Expression ";" --withSerializationAndInit

    // Struct
    Struct = struct id "{" StructBody* "}" --originary
           | message id "{" StructBody* "}" --message
    StructBody = Field

    // Contract
    Contract = contract id "{" ContractBody* "}"
    ContractInit = init "(" ListOf<FunctionArg,","> ")" "{" Statement* "}"
    ContractBody = Field
                 | ContractInit
                 | ReceiveFunction
                 | Function

    // Function
    FunctionAttribute = public --public
                      | get    --getter
                      | mutates --mutates
                      | extends --extends
    Function = FunctionAttribute* fun id "(" ListOf<FunctionArg,","> ")" "{" Statement* "}" --withVoid
             | FunctionAttribute* fun id "(" ListOf<FunctionArg,","> ")" ":" Type "{" Statement* "}" --withType
    FunctionArg = id ":" Type
    ReceiveFunction = receive "(" FunctionArg ")" "{" Statement* "}" --simple
                    | receive  "(" ")" "{" Statement* "}" --empty

    // Statements
    Statement = StatementLet
              | StatementBlock
              | StatementReturn
              | StatementExpression
              | StatementAssign
              | StatementCondition
              | StatementWhile
              | StatementRepeat
              | StatementUntil
    StatementBlock = "{" Statement* "}"
    StatementLet = let id ":" Type "=" Expression ";"
    StatementReturn = return Expression ";"
    StatementExpression = Expression ";"
    StatementAssign = LValue "=" Expression ";"
    StatementCondition = if Expression "{" Statement* "}" ~else --simple
                       | if Expression "{" Statement* "}" else "{" Statement* "}" --withElse
                       | if Expression "{" Statement* "}" else StatementCondition --withElseIf
    StatementWhile = while "(" Expression ")" "{" Statement* "}"
    StatementRepeat = repeat "(" Expression ")" "{" Statement* "}"
    StatementUntil = do "{" Statement* "}" until "(" Expression ")" ";"

    // L-value
    LValue = id "." LValue --more
           | id --single

    // Expressions
    Expression = ExpressionOr
    ExpressionOr = ExpressionOr "||" ExpressionAnd --or
                 | ExpressionAnd
    ExpressionAnd = ExpressionAnd "&&" ExpressionCompare --and
                  | ExpressionCompare
    ExpressionCompare = ExpressionCompare "!=" ExpressionAdd --not
                      | ExpressionCompare "==" ExpressionAdd --eq
                      | ExpressionCompare ">" ExpressionAdd --gt
                      | ExpressionCompare ">=" ExpressionAdd --gte
                      | ExpressionCompare "<" ExpressionAdd --lt
                      | ExpressionCompare "<=" ExpressionAdd --lte
                      | ExpressionAdd
    ExpressionAdd = ExpressionAdd "+" ~"+" ExpressionMul --add
                  | ExpressionAdd "-" ~"-" ExpressionMul --sub
                  | ExpressionMul
    ExpressionMul = ExpressionMul "*" ExpressionUnary --mul
                  | ExpressionMul "/" ExpressionUnary --div
                  | ExpressionUnary
    ExpressionUnary = "-" ExpressionUnarySuffix --neg
                    | "+" ExpressionUnarySuffix --add
                    | "!" ExpressionUnarySuffix --not
                    | ExpressionUnarySuffix
    ExpressionUnarySuffix = ExpressionValue "!!" --notNull
                          | ExpressionValue
    ExpressionBracket = "(" Expression ")"

    // Order is important
    ExpressionValue = ExpressionCall
                    | ExpressionField
                    | ExpressionStaticCall
                    | ExpressionBracket
                    | ExpressionNew
                    | integerLiteral
                    | boolLiteral
                    | id
                    | null
                    
    ExpressionField = ExpressionValue "." id ~"("
    ExpressionCall = ExpressionValue "." id "(" ListOf<Expression, ","> ")"
    ExpressionNew = id "{" ListOf<NewParameter, ","> "}"
    NewParameter = id ":" Expression
    ExpressionStaticCall = id "(" ListOf<Expression, ","> ")"

    // Type Literal
    typeLiteral = letterAsciiUC typeLiteralPart*
    typeLiteralPart = letterAscii | digit | "_"

    // Integer Literal
    // hexDigit defined in Ohm's built-in rules (otherwise: hexDigit = "0".."9" | "a".."f" | "A".."F")
    // digit defined in Ohm's built-in rules (otherwise: digit = "0".."9")
    integerLiteral = integerLiteralHex | integerLiteralDec // Order is important
    integerLiteralDec = digit+
    integerLiteralHex = "0x" hexDigit+
                      | "0X" hexDigit+

    // Letters
    letterAsciiLC = "a".."z"
    letterAsciiUC = "A".."Z"
    letterAscii = letterAsciiLC | letterAsciiUC

    // ID Literal
    idStart = letterAscii | "_"
    idPart = letterAscii | digit | "_"
    id = ~reservedWord #idStart #(idPart*)

    // FunC id
    funcLetter = letterAscii | "_" | "'" | "?" | "!" | "::" | "&"
    funcId = funcLetter #(funcLetter | digit)*

    // Bool Literal
    boolLiteral = ("true" | "false") ~idPart

    // Keywords
    // NOTE Order is important
    keyword = struct 
            | contract 
            | fun 
            | let
            | return 
            | primitive 
            | extend 
            | native 
            | public 
            | get 
            | null 
            | if 
            | else 
            | init 
            | while 
            | repeat 
            | do 
            | until 
            | message 
            | as 
            | receive 
            | mutates
            | extends
    struct = "struct" ~idPart
    contract = "contract" ~idPart
    let = "let" ~idPart
    fun = "fun" ~idPart
    return = "return" ~idPart
    primitive = "primitive" ~idPart
    extend = "extend" ~idPart
    native = "native" ~idPart
    public = "public" ~idPart
    null = "null" ~idPart
    get = "get" ~idPart
    if = "if" ~idPart
    else = "else" ~idPart
    init = "init" ~idPart
    while = "while" ~idPart
    repeat = "repeat" ~idPart
    do = "do" ~idPart
    until = "until" ~idPart
    message = "message" ~idPart
    as = "as" ~idPart
    receive = "receive" ~idPart
    mutates = "mutates" ~idPart
    extends = "extends" ~idPart

    // Attributes
    nameAttribute = "@name"

    // Reserved
    reservedWord = keyword

    // Comments
    space += comment | lineTerminator
    comment = multiLineComment | singleLineComment
    lineTerminator = "\n" | "\r" | "\u2028" | "\u2029"
    multiLineComment = "/*" (~"*/" any)* "*/"
    singleLineComment = "//" (~lineTerminator any)*
}
