Tact {

    // Starting point of the program
    Program = ProgramItem*
    ProgramItem = Struct
                | Contract
                | Primitive
                | StaticFunction

    // Built-in declarations
    Primitive = primitive Type ";"

    // Static function
    StaticFunction = static Function

    // Field declarations
    Type = typeLiteral
    Field = var id ":" Type ";"

    // Struct
    Struct = struct id "{" StructBody* "}"
    StructBody = Field

    // Contract
    Contract = contract id "{" ContractBody* "}"
    ContractBody = Field
                 | Function 

    // Function
    Function = fun id "(" ListOf<FunctionArg,","> ")" ":" Type "{" Statement* "}"
    FunctionArg = id ":" Type

    // Statements
    Statement = StatementLet
              | StatementBlock
              | StatementReturn
    StatementBlock = "{" Statement* "}"
    StatementLet = let id ":" Type "=" Expression ";"
    StatementReturn = return Expression ";"

    // Expressions
    Expression = ExpressionOr
    ExpressionOr = ExpressionOr "||" ExpressionAnd --or
                 | ExpressionAnd
    ExpressionAnd = ExpressionAnd "&&" ExpressionCompare --and
                  | ExpressionCompare
    ExpressionCompare = ExpressionCompare "!=" ExpressionAdd --not
                      | ExpressionCompare "==" ExpressionAdd --eq
                      | ExpressionCompare ">" ExpressionAdd --gt
                      | ExpressionCompare ">=" ExpressionAdd --gte
                      | ExpressionCompare "<" ExpressionAdd --lt
                      | ExpressionCompare "<=" ExpressionAdd --lte
                      | ExpressionAdd
    ExpressionAdd = ExpressionAdd "+" ExpressionMul --add
                  | ExpressionAdd "-" ExpressionMul --sub
                  | ExpressionMul
    ExpressionMul = ExpressionMul "*" ExpressionUnary --mul
                  | ExpressionMul "/" ExpressionUnary --div
                  | ExpressionUnary
    ExpressionUnary = "-" ExpressionUnary --neg
                    | "+" ExpressionUnary --add
                    | "!" ExpressionUnary --not
                    | ExpressionValue
    ExpressionBracket = "(" Expression ")"

    // Order is important
    ExpressionValue = ExpressionCall
                    | ExpressionField
                    | ExpressionBracket
                    | integerLiteral
                    | boolLiteral
                    | id
                    
    ExpressionField = ExpressionValue "." id
    ExpressionCall = ExpressionValue "." id "(" ListOf<Expression, ","> ")"

    // Type Literal
    typeLiteral = letterAsciiUC typeLiteralPart*
    typeLiteralPart = letterAscii | digit | "_"

    // Integer Literal
    // hexDigit defined in Ohm's built-in rules (otherwise: hexDigit = "0".."9" | "a".."f" | "A".."F")
    // digit defined in Ohm's built-in rules (otherwise: digit = "0".."9")
    integerLiteral = integerLiteralHex | integerLiteralDec // Order is important
    integerLiteralDec = digit+
    integerLiteralHex = "0x" hexDigit+
                      | "0X" hexDigit+

    // Letters
    letterAsciiLC = "a".."z"
    letterAsciiUC = "A".."Z"
    letterAscii = letterAsciiLC | letterAsciiUC

    // ID Literal
    idStart = letterAscii
    idPart = letterAscii | digit | "_"
    id = ~reservedWord idStart idPart*

    // Bool Literal
    boolLiteral = ("true" | "false") ~idPart

    // Keywords
    keyword = struct | contract | var | fun | let | return | static | primitive // Order is important
    struct = "struct" ~idPart
    contract = "contract" ~idPart
    var = "var" ~idPart
    let = "let" ~idPart
    fun = "fun" ~idPart
    return = "return" ~idPart
    primitive = "primitive" ~idPart
    static = "static" ~idPart

    // Reserved
    reservedWord = keyword
}
