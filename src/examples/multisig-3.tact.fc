forall X -> tuple __tact_set(tuple x, X v, int i) asm "SETINDEXVARQ";

(slice, [int, int]) __tact_load_address(slice cs) {
    slice raw = cs~load_msg_addr();
    var (r1, r2) = parse_std_addr(raw);
    return (cs, [r1, r2]);
}

builder __tact_store_address(builder b, [int, int] address) {
    b = b.store_uint(2, 2);
    b = b.store_uint(0, 1);
    b = b.store_int(pair_first(address), 8);
    b = b.store_uint(pair_second(address), 256);
    return b;
}

[int, int] __tact_compute_contract_address(int chain, cell code, cell data) {
    var b = begin_cell();
    b = b.store_uint(0, 2);
    b = b.store_uint(3, 2);
    b = b.store_uint(0, 1);
    b = b.store_ref(code);
    b = b.store_ref(data);
    var hash = cell_hash(b.end_cell());
    return [chain, hash];
}

forall X -> tuple __tact_to_tuple(X x) impure asm "NOP";

builder __gen_write_Operation(builder build_0, tuple v) impure {
    var v_0 = at(v, 0);
    var v_1 = at(v, 1);
    var v_2 = at(v, 2);
    build_0 = store_uint(build_0, v_0, 32);
    build_0 = store_coins(build_0, v_1);
    build_0 = __tact_store_address(build_0, v_2);
    return build_0;
}

cell __gen_writecell_Operation(tuple v) impure {
    return __gen_write_Operation(begin_cell(), v).end_cell();
}

(slice, tuple) __gen_read_Operation(slice sc) impure {
    int __seqno = null();
    int __amount = null();
    [int, int] __target = null();
    __seqno = sc~load_uint(32);
    __amount = sc~load_coins();
    __target = sc~__tact_load_address();
    tuple res = empty_tuple();
    res = tpush(res, __seqno);
    res = tpush(res, __amount);
    res = tpush(res, __target);
    return (sc, res);
}

(slice, tuple) __gen_read_Execute(slice sc) impure {
    tuple __operation = null();
    slice __signature1 = null();
    slice __signature2 = null();
    slice __signature3 = null();
    __operation = sc~__gen_read_Operation();
    __signature1 = sc~load_ref().begin_parse();
    __signature2 = sc~load_ref().begin_parse();
    __signature3 = sc~load_ref().begin_parse();
    tuple res = empty_tuple();
    res = tpush(res, __operation);
    res = tpush(res, __signature1);
    res = tpush(res, __signature2);
    res = tpush(res, __signature3);
    return (sc, res);
}

builder __gen_write_MultisigContract(builder build_0, tuple v) impure {
    var v_0 = at(v, 0);
    var v_1 = at(v, 1);
    var v_2 = at(v, 2);
    var v_3 = at(v, 3);
    build_0 = store_uint(build_0, v_0, 32);
    build_0 = store_uint(build_0, v_1, 256);
    build_0 = store_uint(build_0, v_2, 256);
    build_0 = store_uint(build_0, v_3, 256);
    return build_0;
}

cell __gen_writecell_MultisigContract(tuple v) impure {
    return __gen_write_MultisigContract(begin_cell(), v).end_cell();
}

(slice, tuple) __gen_read_MultisigContract(slice sc) impure {
    int __seqno = null();
    int __user1_key = null();
    int __user2_key = null();
    int __user3_key = null();
    __seqno = sc~load_uint(32);
    __user1_key = sc~load_uint(256);
    __user2_key = sc~load_uint(256);
    __user3_key = sc~load_uint(256);
    tuple res = empty_tuple();
    res = tpush(res, __seqno);
    res = tpush(res, __user1_key);
    res = tpush(res, __user2_key);
    res = tpush(res, __user3_key);
    return (sc, res);
}

tuple __gen_load_MultisigContract() inline {
    slice sc = get_data().begin_parse();
    tuple res = sc~__gen_read_MultisigContract();
    return res;
}

() __gen_store_MultisigContract(tuple v) impure {
    builder b = begin_cell();
    b = __gen_write_MultisigContract(b, v);
    set_data(b.end_cell());
}

() send(tuple params) impure {
    builder b = begin_cell();
    b = store_int(b, 0, 1);
    b = store_int(b, true, 1);
    b = store_int(b, at(params, 0), 1);
    b = store_int(b, false, 1);
    b = store_int(b, 0, 2);
    b = __tact_store_address(b, at(params, 1));
    b = store_coins(b, at(params, 2));
    b = store_int(b, false, 1);
    b = store_coins(b, 0);
    b = store_coins(b, 0);
    b = store_uint(b, 0, 64);
    b = store_uint(b, 0, 32);
    b = store_int(b, false, 1);
    b = store_int(b, false, 1);
    cell c = end_cell(b);
    send_raw_message(c, at(params, 3));
}

cell __gen_MultisigContract_init(int key1, int key2, int key3) impure {
    tuple self = __tact_to_tuple([0, null(), null(), null()]);
    self = __tact_set(self, key1, 1);
    self = __tact_set(self, key2, 2);
    self = __tact_set(self, key3, 3);
    return __gen_writecell_MultisigContract(self);
}

(tuple, ()) __gen_MultisigContract_execute(tuple self, tuple op) impure {
    send(__tact_to_tuple([true, at(op, 2), at(op, 1), 0, null()]));
    return (self, ());
}

(tuple, [int, int]) __gen_MultisigContract_testAddress(tuple self) impure {
    return (self, __tact_compute_contract_address(0, end_cell(begin_cell()), end_cell(begin_cell())));
}

_ __gen_get_testAddress() method_id(80602) {
    tuple self = __gen_load_MultisigContract();
    var res = self~__gen_MultisigContract_testAddress();
    return res;
}

(tuple, int) __gen_MultisigContract_key1(tuple self) impure {
    return (self, at(self, 1));
}

_ __gen_get_key1() method_id(107493) {
    tuple self = __gen_load_MultisigContract();
    var res = self~__gen_MultisigContract_key1();
    return res;
}

(tuple, int) __gen_MultisigContract_key2(tuple self) impure {
    return (self, at(self, 2));
}

_ __gen_get_key2() method_id(103302) {
    tuple self = __gen_load_MultisigContract();
    var res = self~__gen_MultisigContract_key2();
    return res;
}

(tuple, int) __gen_MultisigContract_key3(tuple self) impure {
    return (self, at(self, 3));
}

_ __gen_get_key3() method_id(99239) {
    tuple self = __gen_load_MultisigContract();
    var res = self~__gen_MultisigContract_key3();
    return res;
}

(tuple, int) __gen_MultisigContract_seqno(tuple self) impure {
    return (self, at(self, 0));
}

_ __gen_get_seqno() method_id(85143) {
    tuple self = __gen_load_MultisigContract();
    var res = self~__gen_MultisigContract_seqno();
    return res;
}

(tuple, ()) __gen_MultisigContract_receive_Execute(tuple self, tuple msg) impure {
    int op_hash = cell_hash(__gen_writecell_Operation(at(msg, 0)));
    int ok1 = check_signature(op_hash, at(msg, 1), at(self, 1));
    int ok2 = check_signature(op_hash, at(msg, 2), at(self, 2));
    int ok3 = check_signature(op_hash, at(msg, 3), at(self, 3));
    throw_unless(10, (at(at(msg, 0), 0) == at(self, 0)));
    throw_unless(10, ((ok1 & ok2) & ok3));
    self~__gen_MultisigContract_execute(at(msg, 0));
    return (self, ());
}

() recv_internal(cell in_msg_cell, slice in_msg) impure {
    int op = in_msg~load_int(32);
    tuple self = __gen_load_MultisigContract();
    if (op == 819865922) {
        tuple msg = in_msg~__gen_read_Execute();
        self~__gen_MultisigContract_receive_Execute(msg);
    }
    __gen_store_MultisigContract(self);
}

cell init_MultisigContract(int key1, int key2, int key3) method_id {
    return __gen_MultisigContract_init(key1, key2, key3);
}