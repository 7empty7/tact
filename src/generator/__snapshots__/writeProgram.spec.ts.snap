// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`writeProgram should write program 1`] = `
"forall X -> tuple __tact_set(tuple x, X v, int i) asm "SETINDEXVARQ";

forall X -> X __tact_not_null(X x) { throw_if(14, null?(x)); return x; }

(slice, [int, int]) __tact_load_address(slice cs) {
    slice raw = cs~load_msg_addr();
    var (r1, r2) = parse_std_addr(raw);
    return (cs, [r1, r2]);
}

builder __tact_store_address(builder b, [int, int] address) {
    b = b.store_uint(2, 2);
    b = b.store_uint(0, 1);
    b = b.store_int(pair_first(address), 8);
    b = b.store_uint(pair_second(address), 256);
    return b;
}

[int, int] __tact_compute_contract_address(int chain, cell code, cell data) {
    var b = begin_cell();
    b = b.store_uint(0, 2);
    b = b.store_uint(3, 2);
    b = b.store_uint(0, 1);
    b = b.store_ref(code);
    b = b.store_ref(data);
    var hash = cell_hash(b.end_cell());
    return [chain, hash];
}

forall X -> tuple __tact_to_tuple(X x) impure asm "NOP";

forall X -> X __tact_from_tuple(tuple x) impure asm "NOP";

cell __tact_dict_set_int_cell(cell d, int kl, int k, cell v) {
    if (null?(v)) {
        var (r, ok) = idict_delete?(d, kl, k);
        return r;
    } else {
        return idict_set_ref(d, kl, k, v);
    }
}

cell __tact_dict_set_int_int(cell d, int kl, int k, int v, int vl) {
    if (null?(v)) {
        var (r, ok) = idict_delete?(d, kl, k);
        return r;
    } else {
        return idict_set_ref(d, kl, k, begin_cell().store_int(v, vl).end_cell());
    }
}

builder __gen_write_SendParameters(builder build_0, tuple v) impure {
    var [v_0, v_1, v_2, v_3, v_4] = __tact_from_tuple(v);
    build_0 = store_int(build_0, v_0, 1);
    build_0 = __tact_store_address(build_0, v_1);
    build_0 = store_int(build_0, v_2, 257);
    build_0 = store_int(build_0, v_3, 257);
    if (null?(v_4)) {
        build_0 = store_int(build_0, false, 1);
    } else {
        build_0 = store_int(build_0, true, 1);
        build_0 = store_ref(build_0, v_4);
    }
    return build_0;
}

cell __gen_writecell_SendParameters(tuple v) impure {
    return __gen_write_SendParameters(begin_cell(), v).end_cell();
}

slice __gen_writeslice_SendParameters(tuple v) impure {
    return __gen_writecell_SendParameters(v).begin_parse();
}

(slice, tuple) __gen_read_SendParameters(slice sc) impure {
    var __bounce = sc~load_int(1);
    var __to = sc~__tact_load_address();
    var __value = sc~load_int(257);
    var __mode = sc~load_int(257);
    var __body = null();
    if (sc~load_int(1)) {
        var __body = sc~load_ref();
    }
    return (sc, __tact_to_tuple([__bounce, __to, __value, __mode, __body]));
}

builder __gen_write_Point(builder build_0, tuple v) impure {
    var [v_0, v_1] = __tact_from_tuple(v);
    build_0 = store_int(build_0, v_0, 257);
    build_0 = store_int(build_0, v_1, 257);
    return build_0;
}

cell __gen_writecell_Point(tuple v) impure {
    return __gen_write_Point(begin_cell(), v).end_cell();
}

slice __gen_writeslice_Point(tuple v) impure {
    return __gen_writecell_Point(v).begin_parse();
}

(slice, tuple) __gen_read_Point(slice sc) impure {
    var __x = sc~load_int(257);
    var __y = sc~load_int(257);
    return (sc, __tact_to_tuple([__x, __y]));
}

() send(tuple params) impure {
    builder b = begin_cell();
    b = store_int(b, 1, 2);
    b = store_int(b, at(params, 0), 1);
    b = store_int(b, 0, 3);
    b = __tact_store_address(b, at(params, 1));
    b = store_coins(b, at(params, 2));
    b = store_int(b, 0, ((((1 + 4) + 4) + 64) + 32));
    b = store_int(b, false, 1);
    cell body = at(params, 4);
    if ((~ null?(body))) {
        b = store_int(b, true, 1);
        b = store_ref(b, __tact_not_null(body));
    } else {
        b = store_int(b, false, 1);
    }
    cell c = end_cell(b);
    send_raw_message(c, at(params, 3));
}

int improve(tuple p) impure {
    return (at(p, 0) + at(p, 1));
}

int hello_world(int a, int b, tuple p) impure {
    int c = (a + 1);
    c = (c + 1);
    return ((a + b) + improve(p));
}

() recv_internal(cell in_msg_cell, slice in_msg) impure {
    throw(100);
}"
`;
