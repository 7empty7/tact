// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`writeSerialization should write serializer for A 1`] = `
"forall X -> tuple __tact_set(tuple x, X v, int i) asm "SETINDEXVARQ";

forall X -> X __tact_not_null(X x) { throw_if(14, null?(x)); return x; }

(slice, [int, int]) __tact_load_address(slice cs) {
    slice raw = cs~load_msg_addr();
    var (r1, r2) = parse_std_addr(raw);
    return (cs, [r1, r2]);
}

builder __tact_store_address(builder b, [int, int] address) {
    b = b.store_uint(2, 2);
    b = b.store_uint(0, 1);
    b = b.store_int(pair_first(address), 8);
    b = b.store_uint(pair_second(address), 256);
    return b;
}

[int, int] __tact_compute_contract_address(int chain, cell code, cell data) {
    var b = begin_cell();
    b = b.store_uint(0, 2);
    b = b.store_uint(3, 2);
    b = b.store_uint(0, 1);
    b = b.store_ref(code);
    b = b.store_ref(data);
    var hash = cell_hash(b.end_cell());
    return [chain, hash];
}

forall X -> tuple __tact_to_tuple(X x) impure asm "NOP";

forall X -> X __tact_from_tuple(tuple x) impure asm "NOP";

builder __gen_write_A(builder build_0, tuple v) impure {
    var [v_0, v_1, v_2, v_3, v_4, v_5, v_6] = __tact_from_tuple(v);
    build_0 = store_int(build_0, v_0, 257);
    build_0 = store_int(build_0, v_1, 257);
    if (null?(v_2)) {
        build_0 = store_int(build_0, false, 1);
    } else {
        build_0 = store_int(build_0, true, 1);
        build_0 = store_int(build_0, v_2, 257);
    }
    build_0 = store_int(build_0, v_3, 1);
    if (null?(v_4)) {
        build_0 = store_int(build_0, false, 1);
    } else {
        build_0 = store_int(build_0, true, 1);
        build_0 = store_int(build_0, v_4, 1);
    }
    var build_1 = begin_cell();
    build_1 = store_int(build_1, v_5, 257);
    build_1 = store_int(build_1, v_6, 257);
    build_0 = store_ref(build_0, build_1.end_cell());
    return build_0;
}

cell __gen_writecell_A(tuple v) impure {
    return __gen_write_A(begin_cell(), v).end_cell();
}

slice __gen_writeslice_A(tuple v) impure {
    return __gen_writecell_A(v).begin_parse();
}

(slice, tuple) __gen_read_A(slice sc) impure {
    var __a = sc~load_int(257);
    var __b = sc~load_int(257);
    var __c = null();
    if (sc~load_int(1)) {
        var __c = sc~load_int(257);
    }
    var __d = sc~load_int(1);
    var __e = null();
    if (sc~load_int(1)) {
        var __e = sc~load_int(1);
    }
    sc = (sc~load_ref()).begin_parse();
    var __f = sc~load_int(257);
    var __g = sc~load_int(257);
    return (sc, __tact_to_tuple([__a, __b, __c, __d, __e, __f, __g]));
}"
`;

exports[`writeSerialization should write serializer for B 1`] = `
"forall X -> tuple __tact_set(tuple x, X v, int i) asm "SETINDEXVARQ";

forall X -> X __tact_not_null(X x) { throw_if(14, null?(x)); return x; }

(slice, [int, int]) __tact_load_address(slice cs) {
    slice raw = cs~load_msg_addr();
    var (r1, r2) = parse_std_addr(raw);
    return (cs, [r1, r2]);
}

builder __tact_store_address(builder b, [int, int] address) {
    b = b.store_uint(2, 2);
    b = b.store_uint(0, 1);
    b = b.store_int(pair_first(address), 8);
    b = b.store_uint(pair_second(address), 256);
    return b;
}

[int, int] __tact_compute_contract_address(int chain, cell code, cell data) {
    var b = begin_cell();
    b = b.store_uint(0, 2);
    b = b.store_uint(3, 2);
    b = b.store_uint(0, 1);
    b = b.store_ref(code);
    b = b.store_ref(data);
    var hash = cell_hash(b.end_cell());
    return [chain, hash];
}

forall X -> tuple __tact_to_tuple(X x) impure asm "NOP";

forall X -> X __tact_from_tuple(tuple x) impure asm "NOP";

builder __gen_write_B(builder build_0, tuple v) impure {
    var [v_0, v_1, v_2, v_3, v_4, v_5, v_6] = __tact_from_tuple(v);
    build_0 = store_int(build_0, v_0, 257);
    build_0 = store_int(build_0, v_1, 257);
    if (null?(v_2)) {
        build_0 = store_int(build_0, false, 1);
    } else {
        build_0 = store_int(build_0, true, 1);
        build_0 = store_int(build_0, v_2, 257);
    }
    build_0 = store_int(build_0, v_3, 1);
    if (null?(v_4)) {
        build_0 = store_int(build_0, false, 1);
    } else {
        build_0 = store_int(build_0, true, 1);
        build_0 = store_int(build_0, v_4, 1);
    }
    var build_1 = begin_cell();
    build_1 = store_int(build_1, v_5, 257);
    build_1 = store_int(build_1, v_6, 257);
    build_0 = store_ref(build_0, build_1.end_cell());
    return build_0;
}

cell __gen_writecell_B(tuple v) impure {
    return __gen_write_B(begin_cell(), v).end_cell();
}

slice __gen_writeslice_B(tuple v) impure {
    return __gen_writecell_B(v).begin_parse();
}

(slice, tuple) __gen_read_B(slice sc) impure {
    var __a = sc~load_int(257);
    var __b = sc~load_int(257);
    var __c = null();
    if (sc~load_int(1)) {
        var __c = sc~load_int(257);
    }
    var __d = sc~load_int(1);
    var __e = null();
    if (sc~load_int(1)) {
        var __e = sc~load_int(1);
    }
    sc = (sc~load_ref()).begin_parse();
    var __f = sc~load_int(257);
    var __g = sc~load_int(257);
    return (sc, __tact_to_tuple([__a, __b, __c, __d, __e, __f, __g]));
}"
`;

exports[`writeSerialization should write serializer for C 1`] = `
"forall X -> tuple __tact_set(tuple x, X v, int i) asm "SETINDEXVARQ";

forall X -> X __tact_not_null(X x) { throw_if(14, null?(x)); return x; }

(slice, [int, int]) __tact_load_address(slice cs) {
    slice raw = cs~load_msg_addr();
    var (r1, r2) = parse_std_addr(raw);
    return (cs, [r1, r2]);
}

builder __tact_store_address(builder b, [int, int] address) {
    b = b.store_uint(2, 2);
    b = b.store_uint(0, 1);
    b = b.store_int(pair_first(address), 8);
    b = b.store_uint(pair_second(address), 256);
    return b;
}

[int, int] __tact_compute_contract_address(int chain, cell code, cell data) {
    var b = begin_cell();
    b = b.store_uint(0, 2);
    b = b.store_uint(3, 2);
    b = b.store_uint(0, 1);
    b = b.store_ref(code);
    b = b.store_ref(data);
    var hash = cell_hash(b.end_cell());
    return [chain, hash];
}

forall X -> tuple __tact_to_tuple(X x) impure asm "NOP";

forall X -> X __tact_from_tuple(tuple x) impure asm "NOP";

builder __gen_write_C(builder build_0, tuple v) impure {
    var [v_0, v_1, v_2, v_3, v_4, v_5, v_6, v_7] = __tact_from_tuple(v);
    build_0 = store_ref(build_0, v_0);
    if (null?(v_1)) {
        build_0 = store_int(build_0, false, 1);
    } else {
        build_0 = store_int(build_0, true, 1);
        build_0 = store_ref(build_0, v_1);
    }
    if (null?(v_2)) {
        build_0 = store_int(build_0, false, 1);
    } else {
        build_0 = store_int(build_0, true, 1);
        build_0 = store_ref(build_0, v_2.end_cell());
    }
    var build_1 = begin_cell();
    if (null?(v_3)) {
        build_1 = store_int(build_1, false, 1);
    } else {
        build_1 = store_int(build_1, true, 1);
        build_1 = store_ref(build_1, v_3.end_cell());
    }
    build_1 = store_int(build_1, v_4, 1);
    build_1 = store_int(build_1, v_5, 257);
    build_1 = store_int(build_1, v_6, 257);
    build_1 = __tact_store_address(build_1, v_7);
    build_0 = store_ref(build_0, build_1.end_cell());
    return build_0;
}

cell __gen_writecell_C(tuple v) impure {
    return __gen_write_C(begin_cell(), v).end_cell();
}

slice __gen_writeslice_C(tuple v) impure {
    return __gen_writecell_C(v).begin_parse();
}

(slice, tuple) __gen_read_C(slice sc) impure {
    var __a = sc~load_ref();
    var __b = null();
    if (sc~load_int(1)) {
        var __b = sc~load_ref();
    }
    var __c = null();
    if (sc~load_int(1)) {
        var __c = sc~load_ref().begin_parse();
    }
    sc = (sc~load_ref()).begin_parse();
    var __d = null();
    if (sc~load_int(1)) {
        var __d = sc~load_ref().begin_parse();
    }
    var __e = sc~load_int(1);
    var __f = sc~load_int(257);
    var __g = sc~load_int(257);
    var __h = sc~__tact_load_address();
    return (sc, __tact_to_tuple([__a, __b, __c, __d, __e, __f, __g, __h]));
}"
`;
